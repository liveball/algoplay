### 题目描述



300. 最长上升子序列
给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?




分析 递推公式

### 证明此问题具有一个最优的子结构

>1、假设f(n) 是 nums[0,1, ..., n-1] 的最长上升子序列，
   那么 f(n-1) 就是nums[0,1,..., n-2] 的最长上升子序列
   所以f(1) 就是 f(0) 的最长子序列

>2、假设已经处理了 f(1)、f(2)、 ... f(n-1) 的问题，
   那么考虑最后一个数 nums[n-1]，也必然考虑到倒数第2个数nums[n-2]
   所以f(n)指：如果包含了最后的数，最长的子序列应该是什么

   如何通过f(1), f(2),...f(n-1) 推导出f(n) ?
   由于最后一个数是18，
   我们只需要在前面的f(1),f(2),...f(n-1)，
   找出一个小于18的数作为结尾的最长的子序列，然后把18添加到最后，
   那么f(n) 就一定是以18 作为结尾的最长子序列了
   10、18
   9、10、18
   2、9、10、18
   2、5、9、10、18
   2、3、5、9、10、18
   2、3、5、7、9、10、18

   最长的子序列并不一定会包含18，
   遍历f(1),f(2),...f(n-2)，找出最长的，
   例如以101结尾的最长上升子序列是什么。

    总结解决动态规划的两个难点
    >1、如何定义f(n)
    对于这道题目，f(n) 是以nums[n-1] 结尾的最长上升子序列长度
    >2、如何通过f(1),f(2),...f(n-1) 推导出f(n)，即状态转移方程
        本题目中， nums[n-1] 和比它小的每一个nums[i] 进行比较，
        其中1<=i<n, 满足的话计数加1就行
        所以状态转移方程是：
        f(n) = max(f(i)) + 1 (1<=i<n-1, nums[i-1]<nums[n-1])

### 寻找重叠子问题
   在分析最后一个数字18的时候，
   以 3 结尾的最长的上升子序列长度就是 f(5)，因为 3 是第 5 个数
   当前的数字变成101的时候，找比它小的数字，又发现了3，
   这个时候有重复计算了一遍f(5),则说明该题目有重叠子问题
   因为可以使用动态规划的方法来解决这个问题。

递归：
用递归方式求解状态转移方程式：f(n) = max(f(i)) + 1 (1<=i<n-1, nums[i-1]<nums[n-1])
>1、当i=0 的时候，应该返回0
    当i=1 的时候，应该返回1
>2、对于每一个n,要从1开始遍历
>3、递归调用递归函数，找出最大的，最后加上1
>4、在n之前，找出比nums[n-1]小的数
