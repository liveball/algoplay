package my_sort

//冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，
//看是否满足大小关系要求。如果不满足就让它俩互换。
//一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

//时间复杂度 最好 O(n) 最坏O(n^2)
func BubbleSort(a []int) {
	n := len(a)

	if n <= 1 {
		return
	}

	for i := 0; i < n; i++ {

		//当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作
		flag := false
		for j := 0; j < n-i-1; j++ {
			if a[j+1] < a[j] { //小数上浮，大数下沉
				t := a[j]
				a[j] = a[j+1]
				a[j+1] = t
				flag = true // 表示有数据交换
			}
		}

		if !flag { // 没有数据交换，提前退出
			break
		}
	}
}

//插入排序（Insertion Sort）

//我们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？
//很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。

//首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。
//初始已排序区间只有一个元素，就是数组的第一个元素。
//插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，
//并保证已排序区间数据一直有序。
//重复这个过程，直到未排序区间中元素为空，算法结束。

func InsertionSort(a []int) {
	n := len(a)

	if n <= 1 {
		return
	}

	for i := 1; i < n; i++ {
		v := a[i] //待插入的元素

		j := i - 1 //已排序索引
		// 查找插入的位置
		for ; j >= 0; j-- {
			if v < a[j] { //要插入的元素 小于 当前已排序的元素, 则位置往后移动
				a[j+1] = a[j] //数据移动
			} else {
				break
			}
		}

		a[j+1] = v //已排序区间增加元素
	}
}

//选择排序（Selection Sort）
//选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。
//但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

//时间复杂度：
//选择排序空间复杂度为 O(1)，是一种原地排序算法。
//选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。

func SelectionSort(a []int) {
	n := len(a)

	if n <= 1 {
		return
	}

	for i := 0; i < n; i++ {
		min := i

		for j := i + 1; j < n; j++ {
			if a[j] < a[min] {
				min = j
			}
		}

		//交换
		a[i], a[min] = a[min], a[i]
	}
}
